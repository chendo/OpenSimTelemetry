<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenSimTelemetry</title>
    <style>
        /* ==================== CSS Reset & Variables ==================== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #1a1e2e;
            --bg-card: #222840;
            --bg-input: #1a1e2e;
            --bg-inset: #161b2a;
            --accent: #00d68f;
            --accent-dim: rgba(0, 214, 143, 0.3);
            --text-primary: #ffffff;
            --text-secondary: #8b95a5;
            --text-muted: #5a6377;
            --status-active: #00d68f;
            --status-detected: #3b82f6;
            --status-inactive: #ff4757;
            --border-color: rgba(255, 255, 255, 0.06);
            --grid-columns: 12;
            --grid-gap: 10px;
            --grid-row-height: 40px;
            --header-height: 44px;
            --widget-border-radius: 6px;
            --widget-title-height: 30px;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-mono: "SF Mono", "Fira Code", "Cascadia Code", monospace;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* ==================== Header Bar ==================== */
        .header-bar {
            height: var(--header-height);
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-logo {
            font-size: 0.85rem;
            font-weight: 800;
            letter-spacing: 0.05em;
        }
        .header-logo .logo-open { color: var(--text-secondary); }
        .header-logo .logo-sim { color: var(--accent); }
        .header-logo .logo-tel { color: var(--text-secondary); }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-adapters {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-adapter-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
        }
        .dot-active { background: var(--status-active); box-shadow: 0 0 6px var(--status-active); }
        .dot-detected { background: var(--status-detected); }
        .dot-inactive { background: var(--status-inactive); }

        .header-conn {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .header-reset-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .header-reset-btn:hover { border-color: var(--accent); color: var(--accent); }

        /* ==================== Dashboard Grid ==================== */
        #dashboard-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-columns), 1fr);
            grid-auto-rows: var(--grid-row-height);
            gap: var(--grid-gap);
            padding: var(--grid-gap);
            min-height: calc(100vh - var(--header-height));
        }

        /* ==================== Widget Chrome ==================== */
        .widget {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--widget-border-radius);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            transition: box-shadow 0.15s ease;
            min-width: 0;
            min-height: 0;
        }
        .widget:hover { border-color: rgba(255,255,255,0.1); }
        .widget.dragging {
            opacity: 0.85;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .widget.resizing {
            box-shadow: 0 0 0 1px var(--accent);
        }

        .widget-title {
            height: var(--widget-title-height);
            padding: 0 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: grab;
            user-select: none;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.6rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        .widget-title:active { cursor: grabbing; }

        .widget-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent);
            border-radius: 2px;
            flex-shrink: 0;
        }

        .widget-title-text { flex: 1; }

        .widget-close-btn {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.7rem;
            line-height: 1;
            padding: 0;
            flex-shrink: 0;
        }
        .widget-close-btn:hover { background: #ff4757; color: white; }

        .widget-content {
            flex: 1;
            overflow: hidden;
            padding: 10px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .widget-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 14px;
            height: 14px;
            cursor: se-resize;
            z-index: 5;
        }
        .widget-resize-handle::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 6px;
            height: 6px;
            border-right: 1.5px solid var(--text-muted);
            border-bottom: 1.5px solid var(--text-muted);
        }
        .widget:hover .widget-resize-handle::after {
            border-color: var(--accent);
        }

        /* ==================== Common Widget Styles ==================== */
        .metric-label {
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .metric-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.1;
        }

        .metric-unit {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-left: 3px;
            font-weight: 400;
        }

        .metric-cell {
            background: var(--bg-inset);
            border-radius: 4px;
            padding: 8px 10px;
        }

        /* ==================== Vehicle Widget ==================== */
        .vehicle-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            height: 100%;
        }

        .vehicle-grid .metric-cell:first-child {
            grid-column: 1 / -1;
        }
        .vehicle-grid .metric-cell:first-child .metric-value {
            font-size: 2.2rem;
        }

        .vehicle-bar-group {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .vehicle-bar-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
        }

        .vehicle-bar-label {
            width: 28px;
            font-weight: 600;
            color: var(--text-muted);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .vehicle-bar-track {
            flex: 1;
            height: 6px;
            background: var(--bg-inset);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .vehicle-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.08s ease-out;
            position: absolute;
            top: 0;
        }

        .bar-throttle { background: var(--accent); left: 0; }
        .bar-brake { background: #ff4757; left: 0; }
        .bar-steer { background: #ffa502; }

        .vehicle-bar-pct {
            width: 32px;
            text-align: right;
            color: var(--text-secondary);
            font-family: var(--font-mono);
            font-size: 0.65rem;
            flex-shrink: 0;
        }

        /* ==================== G-Force Widget ==================== */
        .gforce-layout {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 6px;
        }

        .gforce-canvas-wrap {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }

        .gforce-canvas-wrap canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .gforce-readouts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            flex-shrink: 0;
        }

        .gforce-cell {
            background: var(--bg-inset);
            border-radius: 4px;
            padding: 6px 8px;
        }

        .gforce-val {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .gforce-val-unit {
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-left: 2px;
        }

        /* ==================== Orientation Widget ==================== */
        .orient-axes {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            justify-content: center;
        }

        .orient-axis {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .orient-header {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .orient-axis-label {
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-secondary);
            width: 36px;
            flex-shrink: 0;
        }

        .orient-angle {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            min-width: 60px;
        }

        .orient-rate {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-family: var(--font-mono);
        }

        .orient-bar-track {
            height: 8px;
            background: var(--bg-inset);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .orient-bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            background: var(--text-muted);
            opacity: 0.5;
        }

        .orient-bar-fill {
            position: absolute;
            top: 0;
            height: 100%;
            background: var(--accent);
            border-radius: 4px;
            transition: left 0.08s ease-out, width 0.08s ease-out;
        }

        /* ==================== Graph Widget ==================== */
        .graph-layout {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 6px;
        }

        .graph-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .graph-legend {
            display: flex;
            gap: 4px 8px;
            flex-wrap: wrap;
            flex: 1;
            min-width: 0;
        }

        .graph-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            cursor: pointer;
            user-select: none;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .graph-legend-item .graph-legend-dot { opacity: 0.3; }
        .graph-legend-item.active { color: var(--text-secondary); }
        .graph-legend-item.active .graph-legend-dot { opacity: 1; }
        .graph-legend-item:hover { background: rgba(255,255,255,0.04); }

        .graph-legend-dot {
            width: 8px;
            height: 3px;
            border-radius: 1px;
            flex-shrink: 0;
        }

        .graph-time-select {
            background: var(--bg-inset);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            cursor: pointer;
        }
        .graph-time-select:focus { outline: none; border-color: var(--accent); }

        .graph-canvas-wrap {
            flex: 1;
            min-height: 0;
        }

        .graph-canvas-wrap canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ==================== Suspension Widget ==================== */
        .susp-layout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 4px 8px;
            height: 100%;
            align-items: center;
            justify-items: center;
        }

        .susp-car-shape {
            grid-column: 2;
            grid-row: 1 / 3;
            width: 32px;
            height: 60px;
            border: 1.5px solid var(--text-muted);
            border-radius: 6px 6px 4px 4px;
            opacity: 0.4;
        }

        .susp-wheel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .susp-label {
            font-size: 0.6rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .susp-bar-track {
            width: 10px;
            height: 40px;
            background: var(--bg-inset);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .susp-bar-fill {
            width: 100%;
            position: absolute;
            bottom: 0;
            background: linear-gradient(0deg, var(--accent), #ffa502, #ff4757);
            border-radius: 4px;
            transition: height 0.08s ease-out;
        }

        .susp-val {
            font-size: 0.6rem;
            font-family: var(--font-mono);
            color: var(--text-muted);
        }

        /* ==================== Lap Timing Widget ==================== */
        .lap-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            height: 100%;
            align-content: start;
        }

        .lap-item {
            background: var(--bg-inset);
            border-radius: 4px;
            padding: 8px 10px;
        }

        .lap-time {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: var(--font-mono);
            color: var(--text-primary);
        }

        .lap-best .lap-time { color: #a855f6; }

        .lap-number {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* ==================== Session Widget ==================== */
        .session-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .session-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            padding: 3px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .session-row:last-child { border-bottom: none; }

        .session-label {
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .session-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .session-adapters {
            margin-top: 6px;
        }

        .session-adapter-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 0;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .section-label-inline {
            font-size: 0.6rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-secondary);
            padding-left: 8px;
            border-left: 2px solid var(--accent);
            margin-top: 8px;
            margin-bottom: 4px;
        }

        /* ==================== All Fields Widget ==================== */
        .fields-filter {
            background: var(--bg-inset);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            width: 100%;
            margin-bottom: 6px;
            flex-shrink: 0;
        }
        .fields-filter:focus { outline: none; border-color: var(--accent); }
        .fields-filter::placeholder { color: var(--text-muted); }

        .fields-list {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .field-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 8px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.7rem;
            font-family: var(--font-mono);
        }
        .field-item:last-child { border-bottom: none; }
        .field-name { color: var(--accent); }
        .field-value { color: var(--text-secondary); }

        /* ==================== Output Sinks Widget ==================== */
        .sink-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 8px;
        }

        .sink-item {
            background: var(--bg-inset);
            padding: 8px 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
        }

        .sink-item strong {
            color: var(--accent);
            font-size: 0.65rem;
        }

        .sink-form {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: flex-end;
        }

        .sink-form select,
        .sink-form input {
            background: var(--bg-inset);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
        }
        .sink-form select:focus,
        .sink-form input:focus { outline: none; border-color: var(--accent); }

        .sink-form-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .sink-form-group {
            display: flex;
            flex-direction: column;
        }

        .btn-add {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .btn-add:hover { opacity: 0.85; }

        .btn-delete {
            background: transparent;
            border: 1px solid #ff4757;
            color: #ff4757;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 600;
            cursor: pointer;
        }
        .btn-delete:hover { background: #ff4757; color: white; }

        .no-data {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-style: italic;
            padding: 12px;
            text-align: center;
        }

        /* ==================== Scrollbar ==================== */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 2px; }
    </style>
</head>
<body>
    <header class="header-bar">
        <span class="header-logo">
            <span class="logo-open">OPEN</span><span class="logo-sim">SIM</span><span class="logo-tel">TELEMETRY</span>
        </span>
        <div class="header-right">
            <span class="header-conn" id="header-conn">
                <span class="status-dot dot-inactive"></span>
                <span>Connecting</span>
            </span>
            <div class="header-adapters" id="header-adapters"></div>
            <button class="header-reset-btn" id="header-add-graph">+ Add Graph</button>
            <button class="header-reset-btn" id="header-reset-layout">Reset Layout</button>
        </div>
    </header>

    <div id="dashboard-grid"></div>

    <script>
    /* ==================== Constants ==================== */
    const LAYOUT_KEY = 'ost-dashboard-layout';
    const LAYOUT_VERSION_KEY = 'ost-dashboard-version';
    const GRAPHS_KEY = 'ost-dashboard-graphs';
    const LAYOUT_VERSION = '3';
    const RAD2DEG = 180 / Math.PI;
    const BUFFER_MAX = 3600;

    /* ==================== Graph Metrics Registry ==================== */
    const GRAPH_METRICS = {
        speed:       { label: 'Speed',      color: '#00d68f', unit: 'km/h',  norm: 'autoscale', extract: f => (f.vehicle?.speed ?? 0) * 3.6 },
        rpm:         { label: 'RPM',        color: '#ff6b6b', unit: 'rpm',   norm: 'autoscale', extract: f => f.vehicle?.rpm ?? 0 },
        throttle:    { label: 'Throttle',   color: '#4ecdc4', unit: '%',     norm: 'pct',       extract: f => f.vehicle?.throttle ?? 0 },
        brake:       { label: 'Brake',      color: '#ff4757', unit: '%',     norm: 'pct',       extract: f => f.vehicle?.brake ?? 0 },
        steering:    { label: 'Steering',   color: '#ffa502', unit: '%',     norm: 'centered',  extract: f => f.vehicle?.steering_angle ?? 0 },
        lat_g:       { label: 'Lateral G',  color: '#a855f6', unit: 'G',     norm: 'centered',  extract: f => f.motion?.g_force?.x ?? 0 },
        long_g:      { label: 'Long G',     color: '#ec4899', unit: 'G',     norm: 'centered',  extract: f => f.motion?.g_force?.z ?? 0 },
        vert_g:      { label: 'Vert G',     color: '#6366f1', unit: 'G',     norm: 'centered',  extract: f => f.motion?.g_force?.y ?? 0 },
        pitch:       { label: 'Pitch',      color: '#f97316', unit: 'deg',   norm: 'centered',  extract: f => (f.motion?.rotation?.x ?? 0) * RAD2DEG },
        yaw_rate:    { label: 'Yaw Rate',   color: '#eab308', unit: 'deg/s', norm: 'centered',  extract: f => (f.motion?.angular_velocity?.y ?? 0) * RAD2DEG },
        roll:        { label: 'Roll',       color: '#14b8a6', unit: 'deg',   norm: 'centered',  extract: f => (f.motion?.rotation?.z ?? 0) * RAD2DEG },
    };
    const GRAPH_METRIC_KEYS = Object.keys(GRAPH_METRICS);

    /* ==================== TelemetryStore ==================== */
    class TelemetryStore {
        constructor() {
            this.currentFrame = null;
            this.adapters = [];
            this.sinks = [];
            this._dirty = false;
            // Ring buffer: fixed-size array with write pointer
            this._ring = new Array(BUFFER_MAX);
            this._head = 0;  // next write position
            this._count = 0; // number of valid entries
        }

        pushFrame(frame) {
            this.currentFrame = frame;
            this._dirty = true;
            const entry = { t: performance.now() };
            for (let i = 0; i < GRAPH_METRIC_KEYS.length; i++) {
                const key = GRAPH_METRIC_KEYS[i];
                entry[key] = GRAPH_METRICS[key].extract(frame);
            }
            this._ring[this._head] = entry;
            this._head = (this._head + 1) % BUFFER_MAX;
            if (this._count < BUFFER_MAX) this._count++;
        }

        // Returns { start, count } indices into ring for the given time window.
        // Caller uses ringAt(idx) to access entries without allocating an array.
        getWindowRange(durationMs, now) {
            if (this._count === 0) return { start: 0, count: 0 };
            const cutoff = now - durationMs;
            const oldest = this._count < BUFFER_MAX ? 0 : this._head;
            // Binary search for first entry >= cutoff
            let lo = 0, hi = this._count;
            while (lo < hi) {
                const mid = (lo + hi) >>> 1;
                if (this._ring[(oldest + mid) % BUFFER_MAX].t < cutoff) lo = mid + 1;
                else hi = mid;
            }
            return { start: (oldest + lo) % BUFFER_MAX, count: this._count - lo };
        }

        ringAt(idx) {
            return this._ring[idx % BUFFER_MAX];
        }
    }

    /* ==================== SSEConnection ==================== */
    class SSEConnection {
        constructor(url, onFrame, onStatusChange) {
            this.url = url;
            this.onFrame = onFrame;
            this.onStatusChange = onStatusChange;
            this.es = null;
            this.delay = 2000;
        }

        connect() {
            if (this.es) this.es.close();
            this.es = new EventSource(this.url);
            this.es.onopen = () => { this.onStatusChange(true); this.delay = 2000; };
            this.es.onerror = () => {
                this.onStatusChange(false);
                this.es.close();
                setTimeout(() => this.connect(), this.delay);
                this.delay = Math.min(this.delay * 1.5, 10000);
            };
            this.es.onmessage = (e) => {
                try { this.onFrame(JSON.parse(e.data)); }
                catch (err) { console.error('Parse error:', err); }
            };
        }
    }

    /* ==================== Widget Visibility Observer ==================== */
    const widgetVisibilityObserver = new IntersectionObserver((entries) => {
        for (const entry of entries) {
            const widget = entry.target._widget;
            if (widget) widget._visible = entry.isIntersecting;
        }
    }, { rootMargin: '50px' });

    /* ==================== Widget Base ==================== */
    class Widget {
        constructor(id, title, defaultLayout) {
            this.id = id;
            this.title = title;
            this.layout = { ...defaultLayout };
            this._visible = true;

            this.element = document.createElement('div');
            this.element.className = 'widget';
            this.element.dataset.widgetId = id;
            this.element._widget = this;

            this.titleBar = document.createElement('div');
            this.titleBar.className = 'widget-title';

            const titleText = document.createElement('span');
            titleText.className = 'widget-title-text';
            titleText.textContent = title;
            this.titleBar.appendChild(titleText);

            this.contentArea = document.createElement('div');
            this.contentArea.className = 'widget-content';

            this.resizeHandle = document.createElement('div');
            this.resizeHandle.className = 'widget-resize-handle';

            this.element.appendChild(this.titleBar);
            this.element.appendChild(this.contentArea);
            this.element.appendChild(this.resizeHandle);
        }

        init() {
            this.buildContent(this.contentArea);
            this.applyLayout();
            widgetVisibilityObserver.observe(this.element);
            return this;
        }

        buildContent(container) {}
        update(store, now) {}
        onResize() {}

        applyLayout() {
            const { col, row, width, height } = this.layout;
            this.element.style.gridColumn = `${col} / span ${width}`;
            this.element.style.gridRow = `${row} / span ${height}`;
        }

        serializeLayout() { return { ...this.layout }; }

        restoreLayout(saved) {
            Object.assign(this.layout, saved);
            this.applyLayout();
        }
    }

    /* ==================== DashboardGrid ==================== */
    class DashboardGrid {
        constructor(container) {
            this.container = container;
            this.widgets = new Map();
            this.columns = 12;
            this.dragState = null;
            this.resizeState = null;

            document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
            document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        }

        addWidget(widget) {
            this.widgets.set(widget.id, widget);
            this.container.appendChild(widget.element);

            widget.titleBar.addEventListener('mousedown', (e) => { e.preventDefault(); this.startDrag(widget, e.clientX, e.clientY); });
            widget.titleBar.addEventListener('touchstart', (e) => { this.startDrag(widget, e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
            widget.resizeHandle.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); this.startResize(widget, e.clientX, e.clientY); });
            widget.resizeHandle.addEventListener('touchstart', (e) => { e.stopPropagation(); this.startResize(widget, e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
        }

        getGridMetrics() {
            const rect = this.container.getBoundingClientRect();
            const gap = parseFloat(getComputedStyle(this.container).gap) || 10;
            const colWidth = (rect.width - gap * (this.columns + 1)) / this.columns;
            const rowHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-row-height')) || 40;
            return { rect, gap, colWidth, rowHeight };
        }

        startDrag(widget, mx, my) {
            this.dragState = { widget, startX: mx, startY: my, startCol: widget.layout.col, startRow: widget.layout.row };
            widget.element.classList.add('dragging');
        }

        startResize(widget, mx, my) {
            this.resizeState = { widget, startX: mx, startY: my, startW: widget.layout.width, startH: widget.layout.height };
            widget.element.classList.add('resizing');
        }

        handleMouseMove(e) { this.handleMove(e.clientX, e.clientY); }
        handleTouchMove(e) {
            if (this.dragState || this.resizeState) {
                e.preventDefault();
                this.handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        getOverlapping(widget, col, row, width, height) {
            const hits = [];
            for (const [id, other] of this.widgets) {
                if (other === widget) continue;
                const o = other.layout;
                if (col < o.col + o.width && col + width > o.col &&
                    row < o.row + o.height && row + height > o.row) hits.push(other);
            }
            return hits;
        }

        handleMove(mx, my) {
            const { gap, colWidth, rowHeight } = this.getGridMetrics();
            const cellW = colWidth + gap;
            const cellH = rowHeight + gap;

            if (this.dragState) {
                const s = this.dragState;
                const dc = Math.round((mx - s.startX) / cellW);
                const dr = Math.round((my - s.startY) / cellH);
                const newCol = Math.max(1, Math.min(s.startCol + dc, this.columns - s.widget.layout.width + 1));
                const newRow = Math.max(1, s.startRow + dr);
                if (newCol === s.widget.layout.col && newRow === s.widget.layout.row) return;

                const hits = this.getOverlapping(s.widget, newCol, newRow, s.widget.layout.width, s.widget.layout.height);
                if (hits.length === 0) {
                    // Free space - just move
                    s.widget.layout.col = newCol;
                    s.widget.layout.row = newRow;
                    s.widget.applyLayout();
                } else if (hits.length === 1) {
                    // Swap position and size with the single overlapped widget
                    const other = hits[0];
                    const prevCol = s.widget.layout.col, prevRow = s.widget.layout.row;
                    const prevW = s.widget.layout.width, prevH = s.widget.layout.height;
                    // Move dragged widget to other's position/size
                    s.widget.layout.col = other.layout.col;
                    s.widget.layout.row = other.layout.row;
                    s.widget.layout.width = other.layout.width;
                    s.widget.layout.height = other.layout.height;
                    // Move other to dragged widget's previous position/size
                    other.layout.col = prevCol;
                    other.layout.row = prevRow;
                    other.layout.width = prevW;
                    other.layout.height = prevH;
                    s.widget.applyLayout(); s.widget.onResize();
                    other.applyLayout(); other.onResize();
                    // Update drag origin so continued dragging works from new position
                    s.startCol = s.widget.layout.col;
                    s.startRow = s.widget.layout.row;
                    s.startX = mx; s.startY = my;
                }
                // If hits > 1, skip (would overlap multiple widgets)
            }

            if (this.resizeState) {
                const s = this.resizeState;
                const dc = Math.round((mx - s.startX) / cellW);
                const dr = Math.round((my - s.startY) / cellH);
                const newW = Math.max(2, Math.min(s.startW + dc, this.columns - s.widget.layout.col + 1));
                const newH = Math.max(2, s.startH + dr);
                const hits = this.getOverlapping(s.widget, s.widget.layout.col, s.widget.layout.row, newW, newH);
                if (hits.length === 0) {
                    s.widget.layout.width = newW;
                    s.widget.layout.height = newH;
                    s.widget.applyLayout();
                    s.widget.onResize();
                }
            }
        }

        handleMouseUp() { this.handleEnd(); }
        handleTouchEnd() { this.handleEnd(); }

        handleEnd() {
            if (this.dragState) {
                this.dragState.widget.element.classList.remove('dragging');
                this.dragState = null;
                this.saveLayout();
            }
            if (this.resizeState) {
                this.resizeState.widget.element.classList.remove('resizing');
                this.resizeState = null;
                this.saveLayout();
            }
        }

        saveLayout() {
            const layouts = {};
            for (const [id, w] of this.widgets) layouts[id] = w.serializeLayout();
            localStorage.setItem(LAYOUT_KEY, JSON.stringify(layouts));
            localStorage.setItem(LAYOUT_VERSION_KEY, LAYOUT_VERSION);
        }

        restoreLayout() {
            if (localStorage.getItem(LAYOUT_VERSION_KEY) !== LAYOUT_VERSION) return false;
            try {
                const layouts = JSON.parse(localStorage.getItem(LAYOUT_KEY));
                if (!layouts) return false;
                for (const [id, w] of this.widgets) {
                    if (layouts[id]) w.restoreLayout(layouts[id]);
                }
                return true;
            } catch { return false; }
        }

        removeWidget(id) {
            const w = this.widgets.get(id);
            if (w) {
                widgetVisibilityObserver.unobserve(w.element);
                w.element.remove();
                this.widgets.delete(id);
                this.saveLayout();
                this.saveGraphConfigs();
            }
        }

        findOpenPosition(width, height) {
            // Find first row where a widget of given size can fit without overlap
            for (let row = 1; row < 100; row++) {
                for (let col = 1; col <= this.columns - width + 1; col++) {
                    if (this.getOverlapping(null, col, row, width, height).length === 0) return { col, row };
                }
            }
            return { col: 1, row: 1 };
        }

        saveGraphConfigs() {
            const configs = [];
            for (const [id, w] of this.widgets) {
                if (w instanceof GraphWidget) {
                    configs.push({ id: w.id, enabledMetrics: [...w.enabledMetrics], timeWindowMs: w.timeWindowMs });
                }
            }
            localStorage.setItem(GRAPHS_KEY, JSON.stringify(configs));
        }

        restoreGraphConfigs() {
            try {
                const saved = JSON.parse(localStorage.getItem(GRAPHS_KEY));
                return Array.isArray(saved) ? saved : null;
            } catch { return null; }
        }

        resetLayout() {
            localStorage.removeItem(LAYOUT_KEY);
            localStorage.removeItem(LAYOUT_VERSION_KEY);
            localStorage.removeItem(GRAPHS_KEY);
            location.reload();
        }
    }

    /* ==================== VehicleWidget ==================== */
    class VehicleWidget extends Widget {
        constructor() { super('vehicle', 'Vehicle', { col: 1, row: 1, width: 4, height: 6 }); }

        buildContent(c) {
            c.innerHTML = `
                <div class="vehicle-grid">
                    <div class="metric-cell">
                        <div class="metric-label">SPEED</div>
                        <div class="metric-value"><span id="v-speed">---</span><span class="metric-unit">km/h</span></div>
                    </div>
                    <div class="metric-cell">
                        <div class="metric-label">RPM</div>
                        <div class="metric-value" id="v-rpm">---</div>
                    </div>
                    <div class="metric-cell">
                        <div class="metric-label">GEAR</div>
                        <div class="metric-value" id="v-gear">N</div>
                    </div>
                    <div class="vehicle-bar-group">
                        <div class="vehicle-bar-item">
                            <span class="vehicle-bar-label">THR</span>
                            <div class="vehicle-bar-track"><div class="vehicle-bar-fill bar-throttle" id="v-thr-bar"></div></div>
                            <span class="vehicle-bar-pct" id="v-thr-pct">0%</span>
                        </div>
                        <div class="vehicle-bar-item">
                            <span class="vehicle-bar-label">BRK</span>
                            <div class="vehicle-bar-track"><div class="vehicle-bar-fill bar-brake" id="v-brk-bar"></div></div>
                            <span class="vehicle-bar-pct" id="v-brk-pct">0%</span>
                        </div>
                        <div class="vehicle-bar-item">
                            <span class="vehicle-bar-label">STR</span>
                            <div class="vehicle-bar-track"><div class="vehicle-bar-fill bar-steer" id="v-str-bar"></div></div>
                            <span class="vehicle-bar-pct" id="v-str-pct">0%</span>
                        </div>
                    </div>
                </div>`;
            this._cache(c, { speed: '#v-speed', rpm: '#v-rpm', gear: '#v-gear',
                thrBar: '#v-thr-bar', thrPct: '#v-thr-pct', brkBar: '#v-brk-bar', brkPct: '#v-brk-pct',
                strBar: '#v-str-bar', strPct: '#v-str-pct' });
        }

        _cache(c, map) { this.els = {}; for (const [k, sel] of Object.entries(map)) this.els[k] = c.querySelector(sel); }

        update(store) {
            const f = store.currentFrame; if (!f) return;
            const v = f.vehicle;
            this.els.speed.textContent = v?.speed != null ? Math.round(v.speed * 3.6) : '---';
            this.els.rpm.textContent = v?.rpm != null ? Math.round(v.rpm) : '---';
            this.els.gear.textContent = v?.gear != null ? (v.gear === -1 ? 'R' : v.gear === 0 ? 'N' : v.gear) : 'N';

            const thr = (v?.throttle ?? 0) * 100;
            this.els.thrBar.style.width = thr + '%';
            this.els.thrPct.textContent = Math.round(thr) + '%';

            const brk = (v?.brake ?? 0) * 100;
            this.els.brkBar.style.width = brk + '%';
            this.els.brkPct.textContent = Math.round(brk) + '%';

            const steer = v?.steering_angle ?? 0;
            const absPct = Math.abs(steer) * 50;
            this.els.strBar.style.width = absPct + '%';
            this.els.strBar.style.left = steer >= 0 ? '50%' : (50 - absPct) + '%';
            this.els.strPct.textContent = Math.round(steer * 100) + '%';
        }
    }

    /* ==================== GForceWidget ==================== */
    class GForceWidget extends Widget {
        constructor() {
            super('gforce', 'G-Force', { col: 5, row: 1, width: 4, height: 6 });
            this.trailMax = 40;
            this._trail = new Array(this.trailMax);
            this._trailHead = 0;
            this._trailCount = 0;
            this.gScale = 2.0;
        }

        buildContent(c) {
            c.innerHTML = `
                <div class="gforce-layout">
                    <div class="gforce-canvas-wrap"><canvas id="gf-canvas"></canvas></div>
                    <div class="gforce-readouts">
                        <div class="gforce-cell"><div class="metric-label">LAT G</div><div class="gforce-val"><span id="gf-lat-num">0.00</span><span class="gforce-val-unit">G</span></div></div>
                        <div class="gforce-cell"><div class="metric-label">LONG G</div><div class="gforce-val"><span id="gf-long-num">0.00</span><span class="gforce-val-unit">G</span></div></div>
                        <div class="gforce-cell"><div class="metric-label">VERT G</div><div class="gforce-val"><span id="gf-vert-num">0.00</span><span class="gforce-val-unit">G</span></div></div>
                        <div class="gforce-cell"><div class="metric-label">YAW RATE</div><div class="gforce-val"><span id="gf-yaw-num">0.0</span><span class="gforce-val-unit">&deg;/s</span></div></div>
                    </div>
                </div>`;
            this.canvas = c.querySelector('#gf-canvas');
            this.ctx = this.canvas.getContext('2d');
            this._cache(c, { lat: '#gf-lat-num', long: '#gf-long-num', vert: '#gf-vert-num', yaw: '#gf-yaw-num' });
        }

        _cache(c, map) { this.valEls = {}; for (const [k, sel] of Object.entries(map)) this.valEls[k] = c.querySelector(sel); }

        update(store, now) {
            const f = store.currentFrame; if (!f) return;
            const gf = f.motion?.g_force;
            const gx = gf?.x ?? 0, gy = gf?.y ?? 0, gz = gf?.z ?? 0;
            // Ring buffer trail
            this._trail[this._trailHead] = { x: gx, y: gz };
            this._trailHead = (this._trailHead + 1) % this.trailMax;
            if (this._trailCount < this.trailMax) this._trailCount++;

            this.valEls.lat.textContent = gx.toFixed(2);
            this.valEls.long.textContent = gz.toFixed(2);
            this.valEls.vert.textContent = gy.toFixed(2);
            const yawRate = (f.motion?.angular_velocity?.y ?? 0) * RAD2DEG;
            this.valEls.yaw.textContent = yawRate.toFixed(1);

            this.renderCanvas();
        }

        renderCanvas() {
            const canvas = this.canvas;
            const dpr = window.devicePixelRatio || 1;
            const wrap = canvas.parentElement;
            const size = Math.min(wrap.clientWidth, wrap.clientHeight);
            if (size <= 0) return;
            const targetW = size * dpr, targetH = size * dpr;
            if (canvas.width !== targetW || canvas.height !== targetH) {
                canvas.width = targetW;
                canvas.height = targetH;
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
            }
            const ctx = this.ctx;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const cx = size / 2, cy = size / 2;
            const radius = size * 0.42;

            ctx.clearRect(0, 0, size, size);

            // Outer circle (dashed, 2G)
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);

            // Inner circle (1G)
            ctx.beginPath(); ctx.arc(cx, cy, radius / this.gScale, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.stroke();

            // Crosshairs
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy); ctx.lineTo(cx + radius, cy);
            ctx.moveTo(cx, cy - radius); ctx.lineTo(cx, cy + radius);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.stroke();

            const scale = radius / this.gScale;
            const toP = (lat, lon) => ({ px: cx + lat * scale, py: cy - lon * scale });

            // Trail (ring buffer iteration, oldest to newest, skip last which is current dot)
            const trailStart = this._trailCount < this.trailMax ? 0 : this._trailHead;
            for (let i = 0; i < this._trailCount - 1; i++) {
                const alpha = (i / this._trailCount) * 0.5;
                const entry = this._trail[(trailStart + i) % this.trailMax];
                const p = toP(entry.x, entry.y);
                ctx.beginPath(); ctx.arc(p.px, p.py, 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0,214,143,${alpha})`; ctx.fill();
            }

            // Current dot
            if (this._trailCount > 0) {
                const last = this._trail[(this._trailHead - 1 + this.trailMax) % this.trailMax];
                const p = toP(last.x, last.y);
                ctx.beginPath(); ctx.arc(p.px, p.py, 6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,214,143,0.3)'; ctx.fill();
                ctx.beginPath(); ctx.arc(p.px, p.py, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#00d68f'; ctx.fill();
            }
        }
    }

    /* ==================== OrientationWidget ==================== */
    class OrientationWidget extends Widget {
        constructor() {
            super('orientation', 'Orientation', { col: 9, row: 1, width: 4, height: 6 });
            this.maxAngle = Math.PI / 4;
        }

        buildContent(c) {
            const axes = ['pitch', 'yaw', 'roll'];
            c.innerHTML = `<div class="orient-axes">${axes.map(a => `
                <div class="orient-axis">
                    <div class="orient-header">
                        <span class="orient-axis-label">${a.toUpperCase()}</span>
                        <span class="orient-angle" id="o-${a}-deg">0.0&deg;</span>
                        <span class="orient-rate" id="o-${a}-rate">0.0 &deg;/s</span>
                    </div>
                    <div class="orient-bar-track">
                        <div class="orient-bar-center"></div>
                        <div class="orient-bar-fill" id="o-${a}-bar"></div>
                    </div>
                </div>`).join('')}</div>`;

            this.axisEls = {};
            for (const a of axes) {
                this.axisEls[a] = {
                    deg: c.querySelector(`#o-${a}-deg`),
                    rate: c.querySelector(`#o-${a}-rate`),
                    bar: c.querySelector(`#o-${a}-bar`),
                };
            }
        }

        update(store) {
            const f = store.currentFrame; if (!f) return;
            const rot = f.motion?.rotation, av = f.motion?.angular_velocity;

            const axes = {
                pitch: { angle: rot?.x ?? 0, rate: av?.x ?? 0 },
                yaw:   { angle: rot?.y ?? 0, rate: av?.y ?? 0 },
                roll:  { angle: rot?.z ?? 0, rate: av?.z ?? 0 },
            };

            for (const [name, data] of Object.entries(axes)) {
                const els = this.axisEls[name];
                const deg = data.angle * RAD2DEG;
                const rateDeg = data.rate * RAD2DEG;

                els.deg.textContent = deg.toFixed(1) + '\u00B0';
                els.rate.textContent = rateDeg.toFixed(1) + ' \u00B0/s';

                const pct = Math.min(Math.abs(data.angle) / this.maxAngle, 1) * 50;
                els.bar.style.width = pct + '%';
                els.bar.style.left = data.angle >= 0 ? '50%' : (50 - pct) + '%';
            }
        }
    }

    /* ==================== GraphWidget ==================== */
    class GraphWidget extends Widget {
        constructor(id, defaultLayout, defaultEnabled) {
            super(id || 'graph', 'Graph', defaultLayout || { col: 1, row: 7, width: 12, height: 6 });
            this.enabledMetrics = new Set(defaultEnabled || ['speed', 'rpm', 'throttle', 'brake']);
            this.timeWindowMs = 10000;
            this.maxSeen = {}; // per-metric max absolute value for auto-scaling
            this.closable = !!id && id !== 'graph'; // default graph is not closable
        }

        buildContent(c) {
            c.innerHTML = `
                <div class="graph-layout">
                    <div class="graph-controls">
                        <div class="graph-legend"></div>
                        <select class="graph-time-select">
                            <option value="10000">10s</option>
                            <option value="30000">30s</option>
                            <option value="60000">60s</option>
                        </select>
                    </div>
                    <div class="graph-canvas-wrap"><canvas></canvas></div>
                </div>`;

            this.canvas = c.querySelector('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.legendEl = c.querySelector('.graph-legend');
            this.legendItems = {};

            this.rebuildLegend();

            const sel = c.querySelector('.graph-time-select');
            sel.value = String(this.timeWindowMs);
            sel.addEventListener('change', (e) => {
                this.timeWindowMs = parseInt(e.target.value);
                if (typeof dashboardSaveGraphs === 'function') dashboardSaveGraphs();
            });

            // Add close button to title bar if closable
            if (this.closable) {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'widget-close-btn';
                closeBtn.textContent = '\u00D7';
                closeBtn.title = 'Remove graph';
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (typeof grid !== 'undefined') grid.removeWidget(this.id);
                });
                this.titleBar.appendChild(closeBtn);
            }
        }

        rebuildLegend() {
            this.legendEl.innerHTML = '';
            this.legendItems = {};
            for (const [key, metric] of Object.entries(GRAPH_METRICS)) {
                const item = document.createElement('span');
                const enabled = this.enabledMetrics.has(key);
                item.className = 'graph-legend-item' + (enabled ? ' active' : '');
                item.innerHTML = `<span class="graph-legend-dot" style="background:${metric.color}"></span>${metric.label}`;
                item.addEventListener('click', () => {
                    if (this.enabledMetrics.has(key)) this.enabledMetrics.delete(key);
                    else this.enabledMetrics.add(key);
                    item.classList.toggle('active', this.enabledMetrics.has(key));
                    if (typeof dashboardSaveGraphs === 'function') dashboardSaveGraphs();
                });
                this.legendEl.appendChild(item);
                this.legendItems[key] = item;
            }
        }

        update(store, now) {
            const canvas = this.canvas;
            const dpr = window.devicePixelRatio || 1;
            const wrap = canvas.parentElement;
            const w = wrap.clientWidth, h = wrap.clientHeight;
            if (w <= 0 || h <= 0) return;
            const needsResize = canvas.width !== (w * dpr) || canvas.height !== (h * dpr);
            if (needsResize) { canvas.width = w * dpr; canvas.height = h * dpr; }
            const ctx = this.ctx;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const pad = { top: 8, right: 8, bottom: 16, left: 36 };
            const pw = w - pad.left - pad.right, ph = h - pad.top - pad.bottom;
            ctx.clearRect(0, 0, w, h);

            const { start, count } = store.getWindowRange(this.timeWindowMs, now);
            if (count < 2) return;

            const tMin = store.ringAt(start).t;
            const tMax = store.ringAt(start + count - 1).t;
            const tRange = Math.max(tMax - tMin, 1);

            // Compute max values for enabled metrics in this window
            for (const key of this.enabledMetrics) {
                const metric = GRAPH_METRICS[key];
                if (!metric) continue;
                if (metric.norm === 'autoscale') {
                    let mx = 0;
                    for (let i = 0; i < count; i++) { const v = Math.abs(store.ringAt(start + i)[key]); if (v > mx) mx = v; }
                    this.maxSeen[key] = Math.max(mx, this.maxSeen[key] || 0, 0.001);
                } else if (metric.norm === 'centered') {
                    let mx = 0;
                    for (let i = 0; i < count; i++) { const v = Math.abs(store.ringAt(start + i)[key]); if (v > mx) mx = v; }
                    this.maxSeen[key] = Math.max(mx, 0.001);
                }
            }

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
            ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.font = '9px sans-serif'; ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (ph / 4) * i;
                ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + pw, y); ctx.stroke();
                ctx.fillText((100 - i * 25) + '%', pad.left - 4, y + 3);
            }

            // Draw each enabled trace
            for (const key of this.enabledMetrics) {
                const metric = GRAPH_METRICS[key];
                if (!metric) continue;
                ctx.beginPath(); ctx.strokeStyle = metric.color; ctx.lineWidth = 1.5;

                for (let i = 0; i < count; i++) {
                    const entry = store.ringAt(start + i);
                    const x = pad.left + ((entry.t - tMin) / tRange) * pw;
                    let val;
                    if (metric.norm === 'pct') {
                        val = entry[key]; // already 0-1
                    } else if (metric.norm === 'centered') {
                        val = 0.5 + entry[key] / ((this.maxSeen[key] || 1) * 2);
                    } else { // autoscale
                        val = entry[key] / (this.maxSeen[key] || 1);
                    }
                    val = Math.max(0, Math.min(1, val));
                    const y = pad.top + ph * (1 - val);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        getConfig() {
            return { id: this.id, enabledMetrics: [...this.enabledMetrics], timeWindowMs: this.timeWindowMs };
        }

        applyConfig(cfg) {
            if (cfg.enabledMetrics) this.enabledMetrics = new Set(cfg.enabledMetrics);
            if (cfg.timeWindowMs) this.timeWindowMs = cfg.timeWindowMs;
            // Update legend toggle states
            for (const [key, item] of Object.entries(this.legendItems || {})) {
                item.classList.toggle('active', this.enabledMetrics.has(key));
            }
            // Update time window select
            const sel = this.contentArea?.querySelector('.graph-time-select');
            if (sel) sel.value = String(this.timeWindowMs);
        }
    }

    /* ==================== SuspensionWidget ==================== */
    class SuspensionWidget extends Widget {
        constructor() {
            super('suspension', 'Suspension', { col: 1, row: 13, width: 4, height: 5 });
            this.ranges = { min: Infinity, max: -Infinity };
        }

        buildContent(c) {
            c.innerHTML = `
                <div class="susp-layout">
                    <div class="susp-wheel" style="grid-column:1;grid-row:1"><span class="susp-label">FL</span><div class="susp-bar-track"><div class="susp-bar-fill" id="s-fl"></div></div><span class="susp-val" id="s-fl-v">--</span></div>
                    <div class="susp-car-shape"></div>
                    <div class="susp-wheel" style="grid-column:3;grid-row:1"><span class="susp-label">FR</span><div class="susp-bar-track"><div class="susp-bar-fill" id="s-fr"></div></div><span class="susp-val" id="s-fr-v">--</span></div>
                    <div class="susp-wheel" style="grid-column:1;grid-row:2"><span class="susp-label">RL</span><div class="susp-bar-track"><div class="susp-bar-fill" id="s-rl"></div></div><span class="susp-val" id="s-rl-v">--</span></div>
                    <div class="susp-wheel" style="grid-column:3;grid-row:2"><span class="susp-label">RR</span><div class="susp-bar-track"><div class="susp-bar-fill" id="s-rr"></div></div><span class="susp-val" id="s-rr-v">--</span></div>
                </div>`;
            this.wEls = {};
            for (const w of ['fl','fr','rl','rr']) {
                this.wEls[w] = { bar: c.querySelector(`#s-${w}`), val: c.querySelector(`#s-${w}-v`) };
            }
        }

        update(store) {
            const f = store.currentFrame; if (!f?.wheels) return;
            const map = { fl: f.wheels.front_left, fr: f.wheels.front_right, rl: f.wheels.rear_left, rr: f.wheels.rear_right };

            for (const wd of Object.values(map)) {
                if (wd?.suspension_travel != null) {
                    const mm = wd.suspension_travel * 1000;
                    if (mm < this.ranges.min) this.ranges.min = mm;
                    if (mm > this.ranges.max) this.ranges.max = mm;
                }
            }

            const range = this.ranges.max - this.ranges.min;
            const pMin = this.ranges.min - range * 0.1;
            const pMax = this.ranges.max + range * 0.1;

            for (const [key, wd] of Object.entries(map)) {
                if (wd?.suspension_travel != null) {
                    const mm = wd.suspension_travel * 1000;
                    let pct = pMax > pMin ? ((mm - pMin) / (pMax - pMin)) * 100 : 50;
                    pct = Math.max(0, Math.min(100, pct));
                    this.wEls[key].bar.style.height = pct + '%';
                    this.wEls[key].val.textContent = mm.toFixed(1) + 'mm';
                }
            }
        }
    }

    /* ==================== LapTimingWidget ==================== */
    class LapTimingWidget extends Widget {
        constructor() { super('laptiming', 'Lap Timing', { col: 5, row: 13, width: 4, height: 5 }); }

        buildContent(c) {
            c.innerHTML = `
                <div class="lap-grid">
                    <div class="lap-item"><div class="metric-label">CURRENT</div><div class="lap-time" id="lt-cur">--:--.---</div></div>
                    <div class="lap-item lap-best"><div class="metric-label">BEST</div><div class="lap-time" id="lt-best">--:--.---</div></div>
                    <div class="lap-item"><div class="metric-label">LAST</div><div class="lap-time" id="lt-last">--:--.---</div></div>
                    <div class="lap-item"><div class="metric-label">LAP</div><div class="lap-number" id="lt-num">--</div></div>
                </div>`;
            this._cache(c, { cur: '#lt-cur', best: '#lt-best', last: '#lt-last', num: '#lt-num' });
        }

        _cache(c, map) { this.els = {}; for (const [k,s] of Object.entries(map)) this.els[k] = c.querySelector(s); }

        update(store) {
            const f = store.currentFrame; if (!f) return;
            const t = f.timing;
            this.els.cur.textContent = t?.current_lap_time != null ? this._fmt(t.current_lap_time) : '--:--.---';
            this.els.best.textContent = t?.best_lap_time != null ? this._fmt(t.best_lap_time) : '--:--.---';
            this.els.last.textContent = t?.last_lap_time != null ? this._fmt(t.last_lap_time) : '--:--.---';
            this.els.num.textContent = t?.lap_number ?? '--';
        }

        _fmt(s) { const m = Math.floor(s / 60); return `${m}:${(s % 60).toFixed(3).padStart(6, '0')}`; }
    }

    /* ==================== SessionWidget ==================== */
    class SessionWidget extends Widget {
        constructor() { super('session', 'Session', { col: 9, row: 13, width: 4, height: 5 }); }

        buildContent(c) {
            c.innerHTML = `
                <div class="session-info">
                    <div class="session-row"><span class="session-label">TRACK</span><span class="session-value" id="ss-track">--</span></div>
                    <div class="session-row"><span class="session-label">CAR</span><span class="session-value" id="ss-car">--</span></div>
                    <div class="session-row"><span class="session-label">SESSION</span><span class="session-value" id="ss-type">--</span></div>
                    <div class="session-row"><span class="session-label">FLAG</span><span class="session-value" id="ss-flag">--</span></div>
                    <div class="session-row"><span class="session-label">TRACK TEMP</span><span class="session-value" id="ss-ttemp">--</span></div>
                    <div class="session-row"><span class="session-label">AIR TEMP</span><span class="session-value" id="ss-atemp">--</span></div>
                </div>
                <div class="section-label-inline">ADAPTERS</div>
                <div id="ss-adapters" class="session-adapters"></div>`;
            this._cache(c, { track: '#ss-track', car: '#ss-car', type: '#ss-type', flag: '#ss-flag',
                ttemp: '#ss-ttemp', atemp: '#ss-atemp', adapters: '#ss-adapters' });
        }

        _cache(c, map) { this.els = {}; for (const [k,s] of Object.entries(map)) this.els[k] = c.querySelector(s); }

        update(store) {
            const f = store.currentFrame;
            if (f) {
                const s = f.session, w = f.weather;
                this.els.track.textContent = s?.track_name ?? '--';
                this.els.car.textContent = s?.car_name ?? '--';
                this.els.type.textContent = s?.session_type ?? '--';
                const flags = s?.flags;
                const flagText = flags ? Object.entries(flags).filter(([,v]) => v === true).map(([k]) => k).join(', ') || 'None' : '--';
                this.els.flag.textContent = flagText;
                this.els.ttemp.textContent = w?.track_temp != null ? w.track_temp.toFixed(0) + '\u00B0C' : '--';
                this.els.atemp.textContent = w?.air_temp != null ? w.air_temp.toFixed(0) + '\u00B0C' : '--';
            }

            // Adapter list (low-frequency update)
            const now = performance.now();
            if (!this._lastAdapterRender || now - this._lastAdapterRender > 2000) {
                this._lastAdapterRender = now;
                this.els.adapters.innerHTML = store.adapters.map(a => `
                    <div class="session-adapter-row">
                        <span class="status-dot ${a.active ? 'dot-active' : a.detected ? 'dot-detected' : 'dot-inactive'}"></span>
                        <span>${a.name}</span>
                    </div>`).join('');
            }
        }
    }

    /* ==================== AllFieldsWidget ==================== */
    class AllFieldsWidget extends Widget {
        constructor() { super('allfields', 'All Fields', { col: 1, row: 18, width: 12, height: 6 }); }

        buildContent(c) {
            c.innerHTML = `<input type="text" class="fields-filter" id="af-filter" placeholder="Filter fields..."><div class="fields-list" id="af-list"></div>`;
            this.filterInput = c.querySelector('#af-filter');
            this.listEl = c.querySelector('#af-list');
            this.filterInput.addEventListener('input', () => this.renderFields());
        }

        update(store, now) {
            this.lastFrame = store.currentFrame;
            if (!this._lastRender || now - this._lastRender > 250) {
                this._lastRender = now;
                this.renderFields();
            }
        }

        renderFields() {
            if (!this.lastFrame) return;
            const filter = this.filterInput.value.toLowerCase();
            const fields = [];
            const extract = (obj, prefix) => {
                for (const [key, value] of Object.entries(obj)) {
                    const fk = prefix ? `${prefix}.${key}` : key;
                    if (value && typeof value === 'object' && !Array.isArray(value)) extract(value, fk);
                    else fields.push({ key: fk, value: typeof value === 'number' ? value.toFixed(4) : JSON.stringify(value) });
                }
            };
            extract(this.lastFrame, '');
            fields.sort((a, b) => a.key.localeCompare(b.key));
            const filtered = filter ? fields.filter(f => f.key.toLowerCase().includes(filter)) : fields;

            // Reuse existing DOM nodes instead of rebuilding via innerHTML
            const existing = this.listEl.children;
            let i = 0;
            for (; i < filtered.length; i++) {
                const f = filtered[i];
                if (i < existing.length) {
                    // Reuse existing node
                    const row = existing[i];
                    const nameEl = row.firstChild, valEl = row.lastChild;
                    if (nameEl.textContent !== f.key) nameEl.textContent = f.key;
                    if (valEl.textContent !== f.value) valEl.textContent = f.value;
                } else {
                    // Create new node
                    const row = document.createElement('div');
                    row.className = 'field-item';
                    const nameEl = document.createElement('span');
                    nameEl.className = 'field-name';
                    nameEl.textContent = f.key;
                    const valEl = document.createElement('span');
                    valEl.className = 'field-value';
                    valEl.textContent = f.value;
                    row.appendChild(nameEl);
                    row.appendChild(valEl);
                    this.listEl.appendChild(row);
                }
            }
            // Remove excess nodes
            while (this.listEl.children.length > filtered.length) {
                this.listEl.lastChild.remove();
            }
        }
    }

    /* ==================== OutputSinksWidget ==================== */
    class OutputSinksWidget extends Widget {
        constructor() { super('sinks', 'Output Sinks', { col: 1, row: 24, width: 12, height: 5 }); this._lastSinkCount = -1; }

        buildContent(c) {
            c.innerHTML = `
                <div id="sk-list" class="sink-list"><div class="no-data">No sinks configured</div></div>
                <div class="section-label-inline">ADD SINK</div>
                <form id="sk-form" class="sink-form">
                    <div class="sink-form-group"><div class="sink-form-label">Type</div><select id="sk-type"><option value="http">HTTP POST</option><option value="udp">UDP</option><option value="file">File (NDJSON)</option></select></div>
                    <div id="sk-type-fields"></div>
                    <div class="sink-form-group"><div class="sink-form-label">Field Filter</div><input type="text" id="sk-mask" placeholder="e.g. rpm,speed,gear"></div>
                    <button type="submit" class="btn-add">Add</button>
                </form>`;

            this.listEl = c.querySelector('#sk-list');
            this.typeFieldsEl = c.querySelector('#sk-type-fields');
            const typeSelect = c.querySelector('#sk-type');
            typeSelect.addEventListener('change', () => this.updateTypeFields(typeSelect.value));
            this.updateTypeFields('http');

            c.querySelector('#sk-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const sinkType = typeSelect.value;
                const config = { id: '', sink_type: { type: sinkType }, field_mask: c.querySelector('#sk-mask').value.trim() || null };
                if (sinkType === 'http') config.sink_type.url = c.querySelector('#sk-url')?.value;
                else if (sinkType === 'udp') { config.sink_type.host = c.querySelector('#sk-host')?.value; config.sink_type.port = parseInt(c.querySelector('#sk-port')?.value); }
                else if (sinkType === 'file') config.sink_type.path = c.querySelector('#sk-path')?.value;
                try { await fetch('/api/sinks', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(config) }); this._lastSinkCount = -1; } catch(e) { console.error(e); }
            });
        }

        updateTypeFields(type) {
            const tf = this.typeFieldsEl;
            if (type === 'http') tf.innerHTML = '<div class="sink-form-group"><div class="sink-form-label">URL</div><input type="url" id="sk-url" placeholder="http://localhost:8080/telemetry" required></div>';
            else if (type === 'udp') tf.innerHTML = '<div class="sink-form-group"><div class="sink-form-label">Host</div><input type="text" id="sk-host" placeholder="127.0.0.1" required></div><div class="sink-form-group"><div class="sink-form-label">Port</div><input type="number" id="sk-port" placeholder="9200" required></div>';
            else if (type === 'file') tf.innerHTML = '<div class="sink-form-group"><div class="sink-form-label">Path</div><input type="text" id="sk-path" placeholder="/tmp/telemetry.ndjson" required></div>';
        }

        update(store) {
            if (store.sinks.length !== this._lastSinkCount) {
                this._lastSinkCount = store.sinks.length;
                if (store.sinks.length === 0) {
                    this.listEl.innerHTML = '<div class="no-data">No sinks configured</div>';
                } else {
                    this.listEl.innerHTML = store.sinks.map(s => {
                        const desc = s.sink_type.type === 'http' ? s.sink_type.url : s.sink_type.type === 'udp' ? `${s.sink_type.host}:${s.sink_type.port}` : s.sink_type.path;
                        return `<div class="sink-item"><div><strong>${s.sink_type.type.toUpperCase()}</strong> ${desc}${s.field_mask ? `<br><span style="color:var(--text-muted);font-size:0.6rem">Fields: ${s.field_mask}</span>` : ''}</div><button class="btn-delete" data-id="${s.id}">Delete</button></div>`;
                    }).join('');
                    this.listEl.querySelectorAll('.btn-delete').forEach(btn => {
                        btn.addEventListener('click', async () => {
                            try { await fetch(`/api/sinks/${btn.dataset.id}`, { method: 'DELETE' }); this._lastSinkCount = -1; } catch(e) { console.error(e); }
                        });
                    });
                }
            }
        }
    }

    /* ==================== Initialization ==================== */
    const store = new TelemetryStore();
    const grid = new DashboardGrid(document.getElementById('dashboard-grid'));

    // Global function for GraphWidget to call when config changes
    function dashboardSaveGraphs() { grid.saveGraphConfigs(); }

    // SSE connection
    const connEl = document.getElementById('header-conn');
    const sse = new SSEConnection('/api/telemetry/stream',
        (frame) => store.pushFrame(frame),
        (connected) => {
            connEl.innerHTML = `<span class="status-dot ${connected ? 'dot-active' : 'dot-inactive'}"></span><span>${connected ? 'Connected' : 'Disconnected'}</span>`;
        }
    );

    // Create static widgets
    const staticWidgets = [
        new VehicleWidget(),
        new GForceWidget(),
        new OrientationWidget(),
        new SuspensionWidget(),
        new LapTimingWidget(),
        new SessionWidget(),
        new AllFieldsWidget(),
        new OutputSinksWidget(),
    ];
    staticWidgets.forEach(w => { w.init(); grid.addWidget(w); });

    // Create graph widgets (restore from saved config, or create default)
    const savedGraphs = grid.restoreGraphConfigs();
    if (savedGraphs && savedGraphs.length > 0) {
        for (const cfg of savedGraphs) {
            const gw = new GraphWidget(cfg.id, null, cfg.enabledMetrics);
            if (cfg.timeWindowMs) gw.timeWindowMs = cfg.timeWindowMs;
            gw.init();
            grid.addWidget(gw);
        }
    } else {
        const defaultGraph = new GraphWidget('graph', { col: 1, row: 7, width: 12, height: 6 }, ['speed', 'rpm', 'throttle', 'brake']);
        defaultGraph.init();
        grid.addWidget(defaultGraph);
    }

    grid.restoreLayout();

    // Add Graph button
    let graphCounter = Date.now();
    document.getElementById('header-add-graph').addEventListener('click', () => {
        const id = 'graph-' + (graphCounter++);
        const pos = grid.findOpenPosition(12, 6);
        const gw = new GraphWidget(id, { col: pos.col, row: pos.row, width: 12, height: 6 }, ['speed', 'rpm', 'throttle', 'brake']);
        gw.init();
        grid.addWidget(gw);
        grid.saveLayout();
        grid.saveGraphConfigs();
    });

    // Header: adapter status dots
    const headerAdapters = document.getElementById('header-adapters');
    function updateHeaderAdapters() {
        headerAdapters.innerHTML = store.adapters.map(a =>
            `<span class="header-adapter-item"><span class="status-dot ${a.active ? 'dot-active' : a.detected ? 'dot-detected' : 'dot-inactive'}"></span>${a.name}</span>`
        ).join('');
    }

    // Reset layout button
    document.getElementById('header-reset-layout').addEventListener('click', () => grid.resetLayout());

    // Render loop (decoupled from SSE)
    function renderLoop() {
        if (store._dirty) {
            store._dirty = false;
            const now = performance.now();
            for (const w of grid.widgets.values()) {
                if (w._visible) w.update(store, now);
            }
        }
        requestAnimationFrame(renderLoop);
    }

    // Polling: adapters every 2s, sinks every 5s
    async function pollAdapters() {
        try { store.adapters = await (await fetch('/api/adapters')).json(); updateHeaderAdapters(); } catch {}
    }
    async function pollSinks() {
        try { store.sinks = await (await fetch('/api/sinks')).json(); } catch {}
    }

    // Start
    sse.connect();
    pollAdapters(); pollSinks();
    setInterval(pollAdapters, 2000);
    setInterval(pollSinks, 5000);
    requestAnimationFrame(renderLoop);
    </script>
</body>
</html>
